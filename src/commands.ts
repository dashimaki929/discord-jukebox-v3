import { randomUUID } from 'crypto';

import {
    ButtonInteraction,
    CommandInteraction,
    ModalSubmitInteraction,
    SlashCommandStringOption,
    SlashCommandChannelOption,
    ActionRowBuilder,
    ButtonBuilder,
    EmbedBuilder,
    ModalBuilder,
    TextInputBuilder,
    ChannelType,
    ButtonStyle,
    TextInputStyle,
    AttachmentBuilder,
} from 'discord.js';
import { getVoiceConnections, joinVoiceChannel } from '@discordjs/voice';
import yts from 'yt-search';

import { Commands } from './typedef.js';
import { Bot } from './class/Bot.js';
import { deleteMessageFromKey, notificationReply, shuffle, updatePlayerButton } from './common/util.js';
import { COLORS, ICONS, IMPORTANT_MESSAGE_DELETE_TIMEOUT_MS, PLAYLISTS, URLS } from './common/constants.js';

export const commands: Commands = {
    /**
     * debug Command
     *      Used for debugging with a running bot.
     */
    debug: {
        description: 'üß∞ „Éá„Éê„ÉÉ„Ç∞',
        options: [
            new SlashCommandStringOption()
                .setName('code')
                .setDescription('ÂÆüË°å„Åô„Çã„Ç≥„Éº„Éâ„ÇíÂÖ•Âäõ')
                .setRequired(true)
        ],
        execute: async (interaction: CommandInteraction, bot: Bot) => {
            if (interaction.user.id !== process.env.DISCORD_HOST_USER_ID) {
                notificationReply(interaction, '‚õî „Åì„ÅÆ„Ç≥„Éû„É≥„Éâ„ÇíÂÆüË°å„Åô„ÇãÊ®©Èôê„Åå„ÅÇ„Çä„Åæ„Åõ„Çì„ÄÇ')
                return;
            }

            try {
                const code = interaction.options.get('code')?.value! as string;
                const result = new Function(`"use strict"; return (async () => { ${code} })()`)();
                interaction.reply({
                    content: ['```json', JSON.stringify(result).substring(0, 1900), '```'].join('\n'),
                    ephemeral: true,
                });
            } catch (error) {
                notificationReply(interaction, ['```', error, '```'].join('\n'));
            }
        }
    },

    /**
     * connect Command
     *      Used for connect a bot to a voice channel.
     */
    connect: {
        description: 'üü¢ „Éú„Ç§„Çπ„ÉÅ„É£„É≥„Éç„É´„Å∏Êé•Á∂ö',
        options: [
            new SlashCommandChannelOption()
                .setName('channel')
                .setDescription('Êé•Á∂öÂÖà„Éú„Ç§„Çπ„ÉÅ„É£„É≥„Éç„É´„ÇíÈÅ∏Êäû')
                .setRequired(true)
                .addChannelTypes(ChannelType.GuildVoice)
        ],
        execute: async (interaction: CommandInteraction, bot: Bot) => {
            const channelId = interaction.options.get('channel')?.value! as string;
            const voiceChannel = interaction.guild?.channels.cache.get(channelId);

            if (voiceChannel) {
                if (!interaction.guild || !interaction.guildId) {
                    notificationReply(interaction, '‚ùå ‰∫àÊúü„Åõ„Å¨„Ç®„É©„Éº„ÅåÁô∫Áîü„Åó„Åæ„Åó„Åü„ÄÇ')
                    return;
                }

                joinVoiceChannel({
                    channelId,
                    guildId: interaction.guildId,
                    adapterCreator: interaction.guild.voiceAdapterCreator,
                });

                const playlist = await yts({ listId: PLAYLISTS[0].hash });
                bot.playlist = playlist.videos.map(v => v.videoId);
                bot.currentPlaylistTitle = playlist.title;
                bot.currentPlaylistUrl = playlist.url;
                bot.initMusicQueue();

                bot.play();

                const channel = await interaction.guild.channels.fetch(interaction.channelId ?? '');
                if (channel?.isTextBased()) {
                    channel.send({
                        embeds: [
                            new EmbedBuilder()
                                .setAuthor({ name: 'Jukebox v3.0.0', iconURL: 'attachment://icon.webp', url: 'https://github.com/dashimaki929/discord-jukebox-v3' })
                                .setTitle('Èü≥Ê•Ω„Çí„É≠„Éº„Éâ‰∏≠...')
                                .setThumbnail('attachment://download.gif')
                                .addFields({
                                    name: '„Éó„É¨„Ç§„É™„Çπ„Éà',
                                    value: bot.currentPlaylistUrl
                                        ? `[${bot.currentPlaylistTitle}](${bot.currentPlaylistUrl})`
                                        : `\`${bot.currentPlaylistTitle}\``
                                })
                                .setImage('attachment://loading.gif')
                        ],
                        files: [
                            new AttachmentBuilder('./img/icon.webp').setName('icon.webp'),
                            new AttachmentBuilder('./img/download.gif').setName('download.gif'),
                            new AttachmentBuilder('./img/loading.gif').setName('loading.gif'),
                        ],
                        components: [
                            new ActionRowBuilder<ButtonBuilder>().addComponents(
                                new ButtonBuilder().setCustomId('loop').setEmoji('1293585939490279424').setStyle(ButtonStyle.Secondary),
                                new ButtonBuilder().setCustomId('shuffle').setEmoji('1293585943621537893').setStyle(ButtonStyle.Secondary),
                                new ButtonBuilder().setCustomId('pause').setEmoji('1293585941067337751').setStyle(ButtonStyle.Primary),
                                new ButtonBuilder().setCustomId('skip').setEmoji('1293585945093738496').setStyle(ButtonStyle.Secondary),
                                new ButtonBuilder().setCustomId('disconnect').setEmoji('1293585937833656453').setStyle(ButtonStyle.Danger),
                            )
                        ],
                    }).then(msg => bot.messages.set('player', msg));
                }

                notificationReply(interaction, `üü¢ „Éú„Ç§„Çπ„ÉÅ„É£„É≥„Éç„É´Ôºà\`${voiceChannel.name}\`Ôºâ„Å´Êé•Á∂ö„Åó„Åæ„Åó„Åü„ÄÇ`)
            } else {
                notificationReply(interaction, '‚ùå ÊåáÂÆö„Åï„Çå„Åü„Éú„Ç§„Çπ„ÉÅ„É£„É≥„Éç„É´„ÅåÂ≠òÂú®„Åó„Åæ„Åõ„Çì„ÄÇ');
            }
        }
    },

    /**
     * disconnect Command
     *      Used for disconnect the bot from the voice channel.
     */
    disconnect: {
        description: 'üî¥ „Éú„Ç§„Çπ„ÉÅ„É£„É≥„Éç„É´„Åã„ÇâÂàáÊñ≠',
        options: [],
        execute: async (interaction: CommandInteraction, bot: Bot) => {
            if (!interaction.guildId) {
                notificationReply(interaction, '‚ùå ‰∫àÊúü„Åõ„Å¨„Ç®„É©„Éº„ÅåÁô∫Áîü„Åó„Åæ„Åó„Åü„ÄÇ')
                return;
            }

            const voiceConnection = getVoiceConnections().get(interaction.guildId);
            if (voiceConnection) {
                voiceConnection.destroy();
                await deleteMessageFromKey(bot, 'player');

                notificationReply(interaction, 'üî¥ „Éú„Ç§„Çπ„ÉÅ„É£„É≥„Éç„É´„Åã„ÇâÂàáÊñ≠„Åó„Åæ„Åó„Åü„ÄÇ');
            } else {
                notificationReply(interaction, '‚ùå Êé•Á∂ö‰∏≠„ÅÆ„Éú„Ç§„Çπ„ÉÅ„É£„É≥„Éç„É´„ÅåÂ≠òÂú®„Åó„Åæ„Åõ„Çì„ÄÇ');
            }
        }
    },

    /**
     * play Command
     *      Used for add music to the queue.
     */
    play: {
        description: 'üéµ Youtube „Åã„ÇâÂãïÁîª„ÇíÊåáÂÆö„Åó„Å¶Èü≥Ê•Ω„ÇíÂÜçÁîü',
        options: [
            new SlashCommandStringOption()
                .setName('play')
                .setDescription('ÂãïÁîª„ÅÆURL„ÇíÂÖ•Âäõ')
                .setRequired(true)
        ],
        execute: async (interaction: CommandInteraction, bot: Bot) => {
            if (!interaction.guildId) return;

            const voiceConnection = getVoiceConnections().get(interaction.guildId);
            if (!voiceConnection) {
                notificationReply(interaction, '‚ùå Êé•Á∂ö‰∏≠„ÅÆ„Éú„Ç§„Çπ„ÉÅ„É£„É≥„Éç„É´„ÅåÂ≠òÂú®„Åó„Åæ„Åõ„Çì„ÄÇ');
                return;
            }

            const url = interaction.options.get('play')?.value! as string;
            const hash = url.match(/[\w-]{11}/);
            if (!hash) {
                notificationReply(interaction, '‚ùå ÂãïÁîª„ÅÆURL„ÅåÊ≠£„Åó„Åè„ÅÇ„Çä„Åæ„Åõ„Çì„ÄÇ');
                return;
            }

            bot.musicQueue.unshift(hash[0]);
            bot.download(bot.musicQueue[0]);

            notificationReply(interaction, ['üéµ Ê•ΩÊõ≤„Çí„Ç≠„É•„Éº„Å´ËøΩÂä†„Åó„Åæ„Åó„Åü„ÄÇ', `${URLS.YOUTUBE}?v=${hash}`].join('\n'));
        }
    },

    /**
     * playlist Command
     *      Used for set up playlists from YouTube.
     */
    playlist: {
        description: 'üé∂ Youtube „Åã„Çâ„Éó„É¨„Ç§„É™„Çπ„Éà„ÇíË®≠ÂÆö',
        options: [
            new SlashCommandStringOption()
                .setName('playlist')
                .setDescription('„Éó„É¨„Ç§„É™„Çπ„Éà„ÅÆURL„ÇíÂÖ•Âäõ')
                .setRequired(true)
                .addChoices(...PLAYLISTS.map(playlist => { return { name: playlist.title, value: playlist.hash } }))
        ],
        execute: async (interaction: CommandInteraction, bot: Bot) => {
            if (!interaction.guildId) return;

            const voiceConnection = getVoiceConnections().get(interaction.guildId);
            if (!voiceConnection) {
                notificationReply(interaction, '‚ùå Êé•Á∂ö‰∏≠„ÅÆ„Éú„Ç§„Çπ„ÉÅ„É£„É≥„Éç„É´„ÅåÂ≠òÂú®„Åó„Åæ„Åõ„Çì„ÄÇ');
                return;
            }

            const url = interaction.options.get('playlist')?.value! as string;
            const hash = url.match(/PL[\w-]{32}/);
            if (!hash) {
                notificationReply(interaction, '‚ùå „Éó„É¨„Ç§„É™„Çπ„Éà„ÅÆURL„ÅåÊ≠£„Åó„Åè„ÅÇ„Çä„Åæ„Åõ„Çì„ÄÇ');
                return;
            }

            const playlist = await yts({ listId: hash[0] });
            if (!playlist.videos.length) {
                notificationReply(interaction, '‚ùå „Éó„É¨„Ç§„É™„Çπ„Éà„ÅåÁ©∫„Åã„ÄÅÂÜçÁîüÂèØËÉΩ„Å™Êõ≤„Åå„ÅÇ„Çä„Åæ„Åõ„Çì„ÄÇ');
                return;
            }

            bot.playlist = playlist.videos.map(v => v.videoId);
            bot.currentPlaylistTitle = playlist.title;
            bot.currentPlaylistUrl = playlist.url;
            bot.initMusicQueue();
            bot.download(bot.musicQueue[0]);

            notificationReply(interaction, ['üé∂ „Éó„É¨„Ç§„É™„Çπ„Éà„ÇíË®≠ÂÆö„Åó„Åæ„Åó„Åü„ÄÇ', playlist.url].join('\n'));
        }
    },

    /**
     * search Command
     *      Used for search for musics from Youtube and add them to the queue.
     */
    search: {
        description: 'üîç YouTube „Åã„ÇâÂãïÁîª„ÇíÊ§úÁ¥¢',
        options: [
            new SlashCommandStringOption()
                .setName('search')
                .setDescription('Ê§úÁ¥¢„ÉØ„Éº„Éâ„ÇíÂÖ•Âäõ')
                .setRequired(true)
        ],
        execute: async (interaction: CommandInteraction, bot: Bot) => {
            if (!interaction.guildId) return;

            const voiceConnection = getVoiceConnections().get(interaction.guildId);
            if (!voiceConnection) {
                notificationReply(interaction, '‚ùå Êé•Á∂ö‰∏≠„ÅÆ„Éú„Ç§„Çπ„ÉÅ„É£„É≥„Éç„É´„ÅåÂ≠òÂú®„Åó„Åæ„Åõ„Çì„ÄÇ');
                return;
            }

            const word = interaction.options.get('search')?.value! as string;
            const result = await yts(word);
            const video = result.videos[0]
            bot.musicQueue.unshift(video.videoId);
            bot.download(bot.musicQueue[0]);

            notificationReply(interaction, ['üéµ Ê•ΩÊõ≤„Çí„Ç≠„É•„Éº„Å´ËøΩÂä†„Åó„Åæ„Åó„Åü„ÄÇ', video.url].join('\n'));
        }
    },

    /**
     * loop Command
     *     Used for toggles between looping.
     */
    loop: {
        description: 'üîÅ „É´„Éº„ÉóÂÜçÁîü„É¢„Éº„Éâ„ÅÆÂàá„ÇäÊõø„Åà',
        options: [],
        execute: async (interaction: CommandInteraction | ButtonInteraction, bot: Bot) => {
            if (!interaction.guildId) return;

            const voiceConnection = getVoiceConnections().get(interaction.guildId);
            if (!voiceConnection) {
                notificationReply(interaction, '‚ùå Êé•Á∂ö‰∏≠„ÅÆ„Éú„Ç§„Çπ„ÉÅ„É£„É≥„Éç„É´„ÅåÂ≠òÂú®„Åó„Åæ„Åõ„Çì„ÄÇ');
                return;
            }

            bot.isLoop = !bot.isLoop;
            updatePlayerButton(bot);

            if (interaction.isButton()) {
                interaction.deferUpdate();
                return;
            }

            notificationReply(interaction, `üîÅ „É´„Éº„ÉóÂÜçÁîü„Åå ${bot.isLoop ? 'ON' : 'OFF'} „Å´„Å™„Çä„Åæ„Åó„Åü„ÄÇ`);
        }
    },

    /**
     * shuffle Command
     *      Used for toggles between shuffling.
     */
    shuffle: {
        description: 'üîÄ „Ç∑„É£„ÉÉ„Éï„É´ÂÜçÁîü„É¢„Éº„Éâ„ÅÆÂàá„ÇäÊõø„Åà',
        options: [],
        execute: async (interaction: CommandInteraction | ButtonInteraction, bot: Bot) => {
            if (!interaction.guildId) return;

            const voiceConnection = getVoiceConnections().get(interaction.guildId);
            if (!voiceConnection) {
                notificationReply(interaction, '‚ùå Êé•Á∂ö‰∏≠„ÅÆ„Éú„Ç§„Çπ„ÉÅ„É£„É≥„Éç„É´„ÅåÂ≠òÂú®„Åó„Åæ„Åõ„Çì„ÄÇ');
                return;
            }

            bot.isShuffle = !bot.isShuffle;
            if (bot.isShuffle) {
                bot.musicQueue = shuffle(bot.musicQueue);
                bot.download(bot.musicQueue[0]);
            }

            updatePlayerButton(bot);

            if (interaction.isButton()) {
                interaction.deferUpdate();
                return;
            }

            notificationReply(interaction, `üîÄ „Ç∑„É£„ÉÉ„Éï„É´ÂÜçÁîü„Åå ${bot.isShuffle ? 'ON' : 'OFF'} „Å´„Å™„Çä„Åæ„Åó„Åü„ÄÇ`);
        }
    },

    /**
     * pause Command
     *      Used for toggles between pausing.
     */
    pause: {
        description: '‚èØ ÂÜçÁîü‰∏≠„ÅÆÊõ≤„Çí‰∏ÄÊôÇÂÅúÊ≠¢ / ‰∏ÄÊôÇÂÅúÊ≠¢‰∏≠„ÅÆÊõ≤„ÇíÂÜçÈñã',
        options: [],
        execute: async (interaction: CommandInteraction | ButtonInteraction, bot: Bot) => {
            if (!interaction.guildId) return;

            const voiceConnection = getVoiceConnections().get(interaction.guildId);
            if (!voiceConnection) {
                notificationReply(interaction, '‚ùå Êé•Á∂ö‰∏≠„ÅÆ„Éú„Ç§„Çπ„ÉÅ„É£„É≥„Éç„É´„ÅåÂ≠òÂú®„Åó„Åæ„Åõ„Çì„ÄÇ');
                return;
            }

            let content = '';
            if (bot.isPlaying) {
                bot.player.pause();
                content = '‚èØ ÂÜçÁîü‰∏≠„ÅÆÊ•ΩÊõ≤„Çí‰∏ÄÊôÇÂÅúÊ≠¢„Åó„Åæ„Åó„Åü„ÄÇ';
            } else {
                bot.player.unpause();
                content = '‚èØ ‰∏ÄÊôÇÂÅúÊ≠¢‰∏≠„ÅÆÊ•ΩÊõ≤„ÇíÂÜçÈñã„Åó„Åæ„Åó„Åü„ÄÇ';
            }

            updatePlayerButton(bot);

            if (interaction.isButton()) {
                interaction.deferUpdate();
                return;
            }

            notificationReply(interaction, content);
        }
    },

    /**
     * skip Command
     *      Used for skip the current music.
     */
    skip: {
        description: '‚è≠Ô∏è ÁèæÂú®„ÅÆÊõ≤„Çí„Çπ„Ç≠„ÉÉ„Éó',
        options: [],
        execute: async (interaction: CommandInteraction | ButtonInteraction, bot: Bot) => {
            if (!interaction.guildId) return;

            const voiceConnection = getVoiceConnections().get(interaction.guildId);
            if (!voiceConnection) {
                notificationReply(interaction, '‚ùå Êé•Á∂ö‰∏≠„ÅÆ„Éú„Ç§„Çπ„ÉÅ„É£„É≥„Éç„É´„ÅåÂ≠òÂú®„Åó„Åæ„Åõ„Çì„ÄÇ');
                return;
            }

            bot.player.stop();
            updatePlayerButton(bot);

            if (interaction.isButton()) {
                interaction.deferUpdate();
                return;
            }

            notificationReply(interaction, '‚è≠Ô∏è ÂÜçÁîü‰∏≠„ÅÆÊ•ΩÊõ≤„Çí„Çπ„Ç≠„ÉÉ„Éó„Åó„Åæ„Åó„Åü„ÄÇ');
        }
    },

    ban: {
        description: 'üö´ ÁèæÂú®„ÅÆÊõ≤„ÇíBAN',
        options: [],
        execute: async (interaction: CommandInteraction, bot: Bot) => {
            if (!interaction.guildId) return;

            const voiceConnection = getVoiceConnections().get(interaction.guildId);
            if (!voiceConnection) {
                notificationReply(interaction, '‚ùå Êé•Á∂ö‰∏≠„ÅÆ„Éú„Ç§„Çπ„ÉÅ„É£„É≥„Éç„É´„ÅåÂ≠òÂú®„Åó„Åæ„Åõ„Çì„ÄÇ');
                return;
            }

            if (!bot.currentMusic) {
                notificationReply(interaction, '‚ùå ÂÜçÁîü‰∏≠„ÅÆÈü≥Ê•Ω„Åå„ÅÇ„Çä„Åæ„Åõ„Çì„ÄÇ');
                return;
            }

            const user = interaction.user;
            bot.addBanlist(bot.currentMusic, `${user.displayName}(${user.tag})<${user.id}> „Å´„Çà„ÇäBAN„Åï„Çå„Åæ„Åó„Åü„ÄÇ`);

            commands.skip.execute(interaction, bot);
        }
    },

    /**
     * spotify Command
     *      Used for integration with spotify.
     */
    spotify: {
        description: 'üåè Spotify„Å®ÈÄ£Êê∫',
        options: [],
        execute: async (interaction: CommandInteraction, bot: Bot) => {
            if (!bot) {
                notificationReply(interaction, '‚ùå „Éú„Ç§„Çπ„ÉÅ„É£„É≥„Éç„É´„Å´Êé•Á∂ö„Åó„Å¶„Åã„ÇâÂÆüË°å„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ')
                return;
            }

            const scopes = ['playlist-read-private', 'user-library-read'];
            const state = randomUUID();
            interaction.reply({
                embeds: [
                    new EmbedBuilder()
                        .setColor(COLORS.SPOTIFY)
                        .setAuthor({ name: 'SpotifyÈÄ£Êê∫', iconURL: ICONS.SPOTIFY })
                        .setTitle('Spotify„Å®„ÅÆÈÄ£Êê∫ÊñπÊ≥ï')
                        .setDescription('„É™„É≥„ÇØ„ÇíÊäº‰∏ã„Åó„Å¶ Spotify „Å´„É≠„Ç∞„Ç§„É≥Âæå„ÄÅÁîªÈù¢„Å´Ë°®Á§∫„Åï„Çå„Çã„Ç≥„Éº„Éâ„ÇíÂÖ•Âäõ„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ')
                ],
                components: [
                    new ActionRowBuilder<ButtonBuilder>().addComponents(
                        new ButtonBuilder().setLabel('„Ç≥„Éº„Éâ„ÇíÂÖ•Âäõ').setCustomId('spotify_code').setStyle(ButtonStyle.Primary),
                        new ButtonBuilder().setLabel('Spotify„Å´„É≠„Ç∞„Ç§„É≥„Åó„Å¶„Ç≥„Éº„Éâ„ÇíÂèñÂæó').setURL(bot.spotifyApi.createAuthorizeURL(scopes, state)).setStyle(ButtonStyle.Link)
                    )
                ],
                ephemeral: true
            }).then(msg => bot.messages.set('spotify', msg));
        }
    },

    /**
     * spotify-code Command
     *      Used for enter Spotifty's authentication code.
     */
    spotify_code: {
        description: '',
        options: [],
        execute: async (interaction: ButtonInteraction) => {
            await interaction.showModal(new ModalBuilder()
                .setCustomId('spotify_auth')
                .setTitle('SpotifyÈÄ£Êê∫')
                .addComponents(new ActionRowBuilder<TextInputBuilder>()
                    .addComponents(new TextInputBuilder()
                        .setCustomId('code')
                        .setLabel('„Ç≥„Éº„Éâ„ÇíÂÖ•Âäõ„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ')
                        .setStyle(TextInputStyle.Paragraph)
                        .setRequired(true)
                    )
                )
            );
        }
    },

    /**
     * spotify-auth Command
     *      Used for authentication with Spotify.
     */
    spotify_auth: {
        description: '',
        options: [],
        execute: async (interaction: ModalSubmitInteraction, bot: Bot) => {
            if (!bot) {
                notificationReply(interaction, '‚ùå „Éú„Ç§„Çπ„ÉÅ„É£„É≥„Éç„É´„Å´Êé•Á∂ö„Åó„Å¶„Åã„ÇâÂÆüË°å„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ')
                return;
            }

            const code = interaction.fields.getTextInputValue('code');
            await bot.spotifyApi.authorizationCodeGrant(code).then(data => {
                bot.spotifyApi.setAccessToken(data.body.access_token);
                bot.spotifyApi.setRefreshToken(data.body.refresh_token);
            }).catch(error => {
                interaction.reply({
                    embeds: [
                        new EmbedBuilder()
                            .setColor(COLORS.ERROR)
                            .setAuthor({ name: 'SpotifyÈÄ£Êê∫', iconURL: ICONS.SPOTIFY })
                            .setTitle('SpotifyÈÄ£Êê∫Â§±Êïó')
                            .setDescription([
                                'Spotify„Ç¢„Ç´„Ç¶„É≥„Éà„ÅÆÈÄ£Êê∫„Å´Â§±Êïó„Åó„Åæ„Åó„Åü„ÄÇ',
                                '```', error, '```'
                            ].join('\n'))
                    ],
                    ephemeral: true
                }).then(msg => setTimeout(() => { msg.delete() }, IMPORTANT_MESSAGE_DELETE_TIMEOUT_MS));
            });

            if (!bot.spotifyApi.getAccessToken() || !bot.spotifyApi.getRefreshToken()) return

            await bot.spotifyApi.getMe().then(data => {
                interaction.reply({
                    embeds: [
                        new EmbedBuilder()
                            .setColor(COLORS.SPOTIFY)
                            .setAuthor({ name: 'SpotifyÈÄ£Êê∫', iconURL: ICONS.SPOTIFY })
                            .setTitle('SpotifyÈÄ£Êê∫ÊàêÂäü')
                            .setDescription([
                                'Spotify„Ç¢„Ç´„Ç¶„É≥„Éà„ÅÆÈÄ£Êê∫„Å´ÊàêÂäü„Åó„Åæ„Åó„Åü„ÄÇ',
                                '```json',
                                JSON.stringify(data, null, '\t'),
                                '```',
                                '',
                                '‰ª•‰∏ã„Ç≥„Éû„É≥„Éâ„Åå„ÅîÂà©Áî®„ÅÑ„Åü„Å†„Åë„Åæ„Åô„ÄÇ'
                            ].join('\n'))
                    ],
                    ephemeral: true
                }).then(msg => setTimeout(() => {
                    deleteMessageFromKey(bot, 'spotify');
                    msg.delete();
                }, IMPORTANT_MESSAGE_DELETE_TIMEOUT_MS));
            }).catch(error => {
                console.error('API„ÅÆÂÆüË°å„Å´Â§±Êïó„Åó„Åæ„Åó„Åü:', error);
            });
        }
    },
}
